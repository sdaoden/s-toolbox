#!/bin/sh
#@ arena-manager for dummies (should work with sh(1), bash(1); and ksh(1)).
#@ Setup your repos once, read this script, and let it do updates in the future
#@ XXX Think about arena-manager[2].pl, which would require per-repo
#@ XXX config files; but like that some hackish things could be made clean,
#@ XXX and it could be even more automatic and it would be explicit what happens
#@ XXX This would also make it safe against (further) changes in git+ namespaces
#
# Copyright (c) 2011 - 2012 Steffen Daode Nurpmeso <sdaoden@users.sf.net>.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
# 3. Neither the name of the author nor the names of its contributors
#    may be used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# And the version control executables
GIT=git
HG=hg
SVN=svn
CVS='cvs -fz 9'
CVS_UPDATE_FLAGS='-AP'

# So what can this script do for you?
# It offers the following modes in an $ARENA of revision control repositories:
#    reduce|expand|gc|fullgc|update|automerge|autogc|checkup|autoup
# Please read all comments of this script before you use it, it was not written
# with public use in mind and thus is a bit complicated to setup.
# This script chooses what to do according to tags that it derives from the
# extension of the repositories top directory:
#
# .git         : git(1)
#           this script assumes local heads under 'refs/heads', and remote
#           heads under 'refs/remotes'...
# .svn_git     : git(1)-svn
#           requires a "pseudo local" reference (update-ref) with the same name
#           as the remote name that git-svn has produced, i.e., if that was
#           '[refs/]remotes/trunk' then do that once:
#           $ git update-ref refs/heads/trunk remotes/trunk
# .cvs_git     : git(1)-cvsimport
#           requires a very special setup!  Please read the update mode!!
# .cvs_bomb_git, .svn_bomb_git, .update_bomb_git:
#           plain git(1) repo inside plain checked out cvs(1)/svn(1) workdir
#           do this once after the initial checkout:
#           $ git init; git add --all; git ci -m created
#           Note that arena-manager will create origin/master and some
#           arena-manager branches as necessary!
#           Better do, for .cvs_bomb_git:
#           $ echo '.#*' >> .git/info/exclude
#           And, absolutely necessary, for .update_bomb_git:
#           $ echo 'svn export http://auau/trunk' > update.sh
#           Or whatever must be in update.sh to update the repo.
#           The repo should possibly be in a further subdirectory.
#           And, also rather for .update_bomb_git only, it is ok if update.sh
#           may itself initiates a commit.
# .sccs_bomb_git: SCCS(1) tree under .git control
# .tar_bomb_git: plain git(1) repo which is updated by exploding tarballs
# .hg          : hg(1) (Mercurial)
# .svn         : svn(1)
# .cvs         : cvs(1)
# .sccs        : sccs(1) (left alone)
#
# All those extensions can be extended with additional tags:
#
# -no_reduce: skip "reduce" and "expand" modes (git(1), hg(1) only)
#           if this is *not* part of the extension the git(1) managed
#           repositories need a branch 'arena-manager-null', which should
#           contain only a single file named 'NULL', which must only consist
#           of a single line with the name of the "master" branch to check out
#           when "expand" is called.  If this file is missing 'master' is used.
#           Mercurial does have a builtin "null" branch and thus simply needs
#           an "update" operation to switch back to the branch which was
#           checked out before "reduce" happened.
# -no_autoup: never perform "update" for this unless the name of the repo
#           was explicitely named on command line.
# -no_fullgc: even with "fullgc", never use --aggressive (git(1) only)
#           "fullgc", and "autogc" every six months, use the --aggressive
#           argument to git-gc.  Some repositories however require hours to
#           finish a fullgc (i.e. the Linux kernel).

##

CVSROOT=/nonexistent
CURR=/nonexistent
# These must be in $ARENA!
LOGFILE=.ARENA-LOG
AUTOGCFILE=.ARENA-AUTOGC
#
ESTAT=0
GITDID=0
AUTOUP=0

log() {
    echo "$*"
    echo "$*" >> $LOGFILE
}
logerr() {
    echo >&2 "ERROR: $*"
    echo "ERROR: $*" >> $LOGFILE
    ESTAT=1
}

SEP='================================================================'
intro() {
    log ''
    log $SEP
    log $1
}
final() {
    if test $1 -eq 0; then
        log "... ok: $2"
    else
        ESTAT=$1
        logerr "$2"
    fi
    log $SEP
}

## git(1) stuff: all called from within subshell with -o pipefail

#git_check_clean() {
#    test 0 != $($GIT clean --dry-run | wc -l | \
#                sed -Ee 's/^[[:space:]]+(.*)$/\1/') && {
#        echo >&2 "Untracked files present, bailing out!" &&
#        exit 10
#    }
#}

git_check_status() {
    test 0 != $($GIT status --short | wc -l | \
                sed -Ee 's/^[[:space:]]+(.*)$/\1/') && {
        echo >&2 "Modified or untracked files present, bailing out!" &&
        exit 10
    }
}

git_checkout() {
    local br="$1"
    $GIT checkout -q -f "$br" -- || {
        echo >&2 "Can't checkout branch $br, bailing out!" &&
        exit 11
    }
}

git_ref_check_gc_update() {
    # Return 41 if no new data, 42 if new data, otherwise error
    local repodir=$1 autogcfile=$2
    $GIT show-ref |
    perl -e "\$rd = \"$repodir\"; \$agcf = \"$autogcfile\";" -e '
        my (%remotes, %heads);
        while (<STDIN>) {
            chomp;
            my ($sha, $ref) = split;
            #print STDERR "sha<$sha> ref<$ref>\n";
            $ref =~ s/^refs\/(.+)/$1/;
            if ($ref =~ s/^remotes\///) {
                $remotes{$ref} = $sha;
            } elsif ($ref =~ s/^heads\///) {
                $heads{$ref} = $sha;
            } elsif ($ref !~ /^tags/) {
                print STDERR "Skipping unrecognized ref $ref\n";
            }
        }

        my $es = 41;
        open AGCF, ">> $agcf" ||
            die "Cannot open append-write $agcf: $!";
        foreach (keys %remotes) {
            (my $lr = $_) =~ s/^origin\///;
            next unless exists $heads{$lr};
            next if $heads{$lr} eq $remotes{$_};
            $es = 42;
            print "... {at least \"$lr\" and \"remotes/$_\" differ, ",
                  "marking for autogc}\n";
            print AGCF $rd, "\n" || die "Cannot write $agcf: $!";
            last;
        } 
        close AGCF || die "Cannot close $agcf: $!";
        exit $es;
    '
    return $?
}

## misc

xy_bomb_git_update() {
    local comm=$1 commname=$2 modlns=0 es

    # (We need to compare local master and remote to detect wether there were
    # updates; arena-manager2/.pl ...)
    $GIT checkout -q -f -B arena-manager-download master -- || {
        echo >&2 "Can't reset branch arena-manager-download, bailing out!" &&
        exit 20
    }
    $GIT update-ref refs/remotes/origin/master arena-manager-download || {
        echo >&2 "Can't reset branch origin/master, bailing out!" &&
        exit 21
    }

    $comm
    es=$?

    # Commit was performed by update.sh script?
    if [ "$($GIT show-ref refs/heads/master)" != \
            "$($GIT show-ref refs/heads/arena-manager-download)" ]; then
        modlns=1
        $GIT update-ref refs/remotes/origin/master arena-manager-download \
            || exit 24
        echo "$rd" >> "$ARENA/$AUTOGCFILE" || exit 25
    else
        # Ignore all updates which occur in .svn/CVS directories, at least for
        # checking wether any repo content has been updated.
        # To avoid problems with DOS/Unix newline changes in working
        # directories, don't use status but this hint (note this new approach
        # would allow for changing some sed(1) REs, but .. just wait a bit xxx)
        modlns=$($GIT add --all --dry-run 2>/dev/null |
                sed -Ee '/(\.svn|CVS|SCCS)\/.*$/d' \
                    -Ee '/\.git/d' -Ee '/\/?\.#/d' |
                wc -l |
                sed -Ee 's/^[[:space:]]+(.*)$/\1/')
        if test x0 != x$modlns; then
            echo "... $commname updated some, initiating git(1) commit"
            $GIT add --all || exit 22
            $GIT commit -m \
                    "arena-manager: $commname update, $(date +'%FT%T%z')" \
                || exit 23
            $GIT update-ref refs/remotes/origin/master arena-manager-download \
                || exit 24
            echo "$rd" >> "$ARENA/$AUTOGCFILE" || exit 25
        fi
    fi

    if test x0 == x$modlns; then
        $GIT reset -q --hard HEAD || exit 26
        echo "... $commname did not seem to have new data"
    fi

    git_checkout master
    return $es
}

## modes

reduce_expand() {
    if test "$MODE" == reduce; then
        git_branch='arena-manager-null'
        hg_branch='null'
    else
        git_branch=
        hg_branch=''
    fi

    for rd in ${params[@]}; do
        if [[ "$rd" != "${rd/no_reduce/}" || ! ( "$rd" != "${rd/git}" ||
              "$rd" != "${rd/hg}" ) ]]; then
            log ''
            log "[$rd: $MODE does not apply]"
            continue
        fi

        intro "$rd: performing $MODE"
        set -o pipefail
        (   cd "$rd" || exit 10
            if test "$rd" != "${rd/git}"; then
                # File NULL on branch arena-manager-null contains a single
                # line stating the master branch's name
                if test -z "$git_branch"; then
                    if test -f NULL; then
                        git_branch=$(< NULL)
                    else
                        echo >&2 "No file NULL in $rd"
                        git_branch=master
                    fi
                fi
                git_checkout "$git_branch"
            else #elif test "$rd" != "${rd/hg}"; then
                $HG up $hg_branch
            fi
            exit $?
        ) 2>&1 | tee -a "$LOGFILE"
        final $? "$rd"
        set +o pipefail
    done
}

xgc() {
    GCT=
    test "$MODE" == fullgc && GCT=--aggressive
    for rd in ${params[@]}; do
        if test "$rd" == "${rd/git}"; then
            log ''
            log "[$rd: $MODE does not apply]"
            continue
        fi
        m=$MODE
        i=$GCT
        if test "$rd" != "${rd/no_fullgc}"; then
            m='gc (fullgc forcefully downgraded)'
            i=
        fi
        intro "$rd: performing $m"
        set -o pipefail
        (   cd "$rd" || exit 1
            time git gc $i
        ) 2>&1 | tee -a "$LOGFILE"
        final $? "$rd"
        set +o pipefail
    done
}

update() {
    rm -rf $AUTOGCFILE || {
        echo >&2 "Failed to remove stale $AUTOGCFILE"
        exit 1
    }

    for rd in ${params[@]}; do
        if test $AUTOUP -ne 0 && test "$rd" != "${rd/no_autoup/}"; then
            log ''
            log "[$rd: $MODE does not apply]"
            continue
        fi
        if test "$rd" != "${rd/.tar_bomb_git}" ||
                test "$rd" != "${rd/.sccs_bomb_git}"; then
            log ''
            log "[$rd: (automatic) $MODE does not apply]"
            continue
        fi

        intro "$rd: performing $MODE"
        set -o pipefail
        (   cd "$rd" || exit 9
            if test "$rd" == ${rd/git}; then
                if test "$rd" != "${rd/.hg}"; then
                    # TODO use incoming, and produce an AUTOGC entry if there
                    # TODO are any revisions; then pull that and rm it!!
                    $HG pull -u
                    es=$?
                elif test "$rd" != "${rd/.svn}"; then
                    $SVN update
                    es=$?
                elif test "$rd" != "${rd/.cvs}"; then
                    $CVS update $CVS_UPDATE_FLAGS
                    es=$?
                elif test "$rd" != "${rd/.sccs}"; then
                    echo "SCCS(1) managed tree, skip: $rd"
                    es=0
                else
                    echo >&2 "Unknown revision-control-system: $rd"
                    es=1
                fi
                exit $es
            fi

            # git(1) and related
            git_check_status

            if test "$rd" != "${rd/.git}"; then
                #$GIT pull -v --ff-only --stat --prune
                $GIT fetch --verbose --prune
                es=$?
                test $es -eq 0 &&
                    git_ref_check_gc_update "$rd" "$ARENA/$AUTOGCFILE"
            elif test "$rd" != "${rd/.update_bomb_git}"; then
                xy_bomb_git_update "sh -c update.sh" 'update.sh'
                es=$?
            elif test "$rd" != "${rd/.svn_bomb_git}"; then
                xy_bomb_git_update "$SVN update" 'svn(1)'
                es=$?
            elif test "$rd" != "${rd/.svn_git}"; then
                # This auto-merges into "master", so that there can be found no
                # indication of wether there were updates or not; thus the
                # local "pseudo" branch we use for that (better solution is
                # clear, maybe in arena-manager.pl which is single instance and
                # can store all refs before in memory and compare against refs
                # after)
                $GIT svn rebase
                es=$?
                test $es -eq 0 &&
                    git_ref_check_gc_update "$rd" "$ARENA/$AUTOGCFILE"
            elif test "$rd" != "${rd/.cvs_bomb_git}"; then
                xy_bomb_git_update "$CVS update $CVS_UPDATE_FLAGS" 'cvs(1)'
                es=$?
            elif test "$rd" != "${rd/.cvs_git}"; then
                # This is more complicated; you need to setup a branch
                # arena-manager-config; check that out
                git_checkout arena-manager-config

                # It contains several files which are used to store the config
                master=$(< git_master)          # The name of the master branch
                cvs_root=$(< cvs_root)          # CVSROOT repo URL (CVS/Root)
                cvs_module=$(< cvs_module)      # CVS module (CVS/Repository)
                # The name of the cvsps(1) cache file is stored in here;
                # that file itself is always stored as 'cvsps_cache' instead
                cvsps_file=$(< cvsps_file)
                # Up to you wether you want -R or not
                test -f cvs-revisions && Rflag=-R || Rflag= # git cvsimport dat

                # Prepare cvsps(1) (and git(1) cvsimport) cache
                cvsps_dir="$HOME/.cvsps"
                test -d "$cvsps_dir" || mkdir "$cvsps_dir" || {
                    echo >&2 "$rd: failed to create $cvsps_dir directory"
                    exit 20
                }
                test x"$Rflag" != x && cp -f cvs-revisions .git/
                cp -f cvsps_cache "$cvsps_dir/$cvsps_file"

                # NOTE: we *require* these -r -d etc... TODO maybe it would be
                # TODO better to offer a "cvsimport-setup"?  arena-manager.pl..
                $GIT cvsimport -ai $Rflag -p '-u,--cvs-direct' \
                     -r origin -d "$cvs_root" "$cvs_module"
                es=$?
                test $es -ne 0 && {
                    echo >&2 "$rd git(1) cvsimport failed, bailing out"
                    git_checkout "$master"
                    exit $es
                }

                # Again, don't create commits unless any repository content has
                # been updated; cvsps(1) always recreates it's cache file...
                git_ref_check_gc_update "$rd" "$ARENA/$AUTOGCFILE"
                if test $? -eq 42; then
                    echo '... committing updated configuration'
                    test x"$Rflag" != x && mv -f .git/cvs-revisions .
                    mv -f "$cvsps_dir/$cvsps_file" cvsps_cache
                    $GIT add --all || exit 21
                    $GIT commit -m 'arena-manager .cvs_git update' || exit 22
                else
                    echo '... cvsimport had nothing, not updating config'
                    test x"$Rflag" != x && rm -f .git/cvs-revisions
                    rm -f "$cvsps_dir/$cvsps_file"
                fi

                git_checkout "$master"
            else
                echo >&2 "Unknown revision-control-system: $rd"
                es=1
            fi
            exit $es
        ) 2>&1 | tee -a "$LOGFILE"
        es=$?
        set +o pipefail
        final $es "$rd"
    done

    test -s "$AUTOGCFILE" && GITDID=1
}

automerge() {
    if test ! -s "$AUTOGCFILE"; then
        logerr 'Necessary information for automerge is missing'
        exit 1
    fi
    for rd in $(< "$AUTOGCFILE"); do
        if test "$rd" == "${rd/git}"; then
            log ''
            log "[$rd: $MODE does not apply]"
            continue
        fi

        intro "$rd: performing $MODE"
        set -o pipefail
        (   cd "$rd" || exit 9
            git_check_status
            # This works with our hackish approach, but is rather unnecessary;
            # if we would have configuration files, it would be so clear!
            # arena-manager.pl could do a much better job!
            master=$($GIT rev-parse --symbolic-full-name HEAD | \
                     sed -e 's/^refs\/heads\///')
            test "$rd" != ${rd/.svn_git} && issvn=1 || issvn=0
            perl -e "\$git = \"$GIT\"; \$is_svn = $issvn;" -e '
                my (%remotes, %heads, @reflines);
                open RLPIPE, "$git show-ref |" or die "Cannot read refs";
                @reflines = <RLPIPE>;
                close RLPIPE;
                while (@reflines) {
                    my $l = pop @reflines;
                    chomp $l;
                    my ($sha, $ref) = split /\s+/, $l;
                    $ref =~ s/^refs\/(.+)/$1/;
                    if ($ref =~ s/^remotes\///) {
                        $remotes{$ref} = $sha;
                    } elsif ($ref =~ s/^heads\///) {
                        $heads{$ref} = $sha;
                    } elsif ($ref !~ /^tags/) {
                        print STDERR "Skipping unrecognized ref $ref\n";
                    }
                }

                my $es = 0;
                foreach (keys %remotes) {
                    (my $lr = $_) =~ s/^origin\///;
                    next unless exists $heads{$lr};
                    next if $heads{$lr} eq $remotes{$_};
                    if ($is_svn) {
                        print "\n... git-svn performs automerge, ",
                              "so update-ref $lr\n";
                        system("$git update-ref " .
                               "refs/heads/$lr refs/remotes/$_");
                        $es |= $?;
                    } else {
                        print "\n... Performing automerge from $_ to $lr\n";
                        system("$git checkout -q -f $lr; " .
                               "$git merge --ff-only $_");
                        $es |= $?;
                    }
                } 
                exit $es;
            '
            es=$?
            git_checkout "$master"
        ) 2>&1 | tee -a "$LOGFILE"
        es=$?
        set +o pipefail
        final $es "$rd"
    done
}

autogc() {
    if test ! -s "$AUTOGCFILE"; then
        logerr 'Necessary information for autogc is missing'
        exit 1
    fi
    unset params
    typeset -a params
    for r in $(< "$AUTOGCFILE"); do
        params[${#params[*]}]="$r"
    done
    # Do a full --aggressive gc every three months
    m=$(date +%m)
    if test $(( ${m#0} % 6 )) -eq 0; then
        MODE=fullgc
        log 'Turned over to mode fullgc (full because MONTH % 6 == 0)'
    else
        MODE=gc
        log 'Turned over to mode gc'
    fi
    xgc
}

checkup() {
    es=0
    log 'Checking how likely it is an update would succeed'
    for rd in ${params[@]}; do
        if test $AUTOUP -ne 0 && test "$rd" != "${rd/no_autoup/}"; then
            log "  [$rd: -no_autoup tag, skip]"
            continue
        fi
        if test "$rd" != "${rd/git}"; then
            action="$GIT status --short"
        elif test "$rd" != "${rd/.hg}"; then
            action="$HG status"
        else
            log "  [$rd: $MODE does not apply]"
            continue
        fi
        if test 0 != $(cd "$rd" && $action | wc -l | \
                       sed -Ee 's/^[[:space:]]+(.*)$/\1/'); then
            log "! $rd: modified or untracked files present!"
            es=1
        else
            log "  $rd: looks good"
        fi
    done
    test $es -ne 0 && {
        echo >&2 "Some repositories need a hand first"
        exit $es
    }
}

## exec

# Top dir where everything happens
if test x"$ARENA" = x; then
    echo >&2 "(Environment) variable ARENA is not set"
    exit 1
fi
cd $ARENA || {
    echo >&2 "Failed to chdir to ARENA=$ARENA"
    exit 1
}

if test -e $LOGFILE; then
    mv -f $LOGFILE "${LOGFILE}-LAST" || {
        echo >&2 "Failed to move old $LOGFILE to ${LOGFILE}-LAST"
        exit 1
    }
fi

MODE="$1"
shift
PARAMS="$@"
set -u
test $# -ne 0 || {
    AUTOUP=1
    PARAMS=$(echo *.*)
}
typeset -a params

# Perform basename cleanup and move over to $params[]
# However, autogc mode takes precedence and is mapped to one of fullgc/gc,
# replacing the PARAMS with the content of $AUTOGCFILE
log "$0: script startup, mode $MODE"
if test "$MODE" != autogc; then
    for rd in $PARAMS; do
        rd=$(echo "$rd" | sed -Ee 's/(.+)\/+$/\1/' -e 's/.*\/([^/]+)$/\1/')
        params[${#params[*]}]="$rd"
    done
fi

case "$MODE" in
reduce|expand)  reduce_expand;;
fullgc|gc)      xgc;;
update)         update;;
automerge)      automerge;;
autogc)         autogc;;
checkup)        checkup;;
autoup)
    MODE='autoup: checkup'
    checkup
    if test -x ./autoup-prehook; then
        MODE='autoup: running autoup-prehook'
        ./autoup-prehook || exit 100
    fi
    MODE='autoup: update'
    update
    if test ! -s "$AUTOGCFILE"; then
        log ''
        log 'It seems there is no new data at all, skipping merge+gc'
    else
        MODE='autoup: automerge'
        automerge
        if test -x ./autoup-posthook; then
            MODE='autoup: running autoup-posthook'
            ./autoup-posthook || exit 101
        fi
        MODE='autoup: autogc'
        autogc
        GITDID=0
    fi
    ;;
*)
    echo 'USAGE: arena-manager MODE [LIST-OF-DIRS]'
    echo 'MODEs: reduce|expand|gc|fullgc|update|automerge|autogc|checkup|autoup'
    exit 1
    ;;
esac

log ''
log '++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++'
if test $GITDID -ne 0; then
    log 'Some git(1) repos seem to have new packs, run arena-manager autogc'
fi
if test $ESTAT -ne 0; then
    log 'Errors occurred!  Ooooh, my gooooooood!  :)'
else
    log 'All seems fine around here, ciao'
fi
exit $ESTAT
# vim:set fenc=utf-8 filetype=sh syntax=sh ts=4 sts=4 sw=4 et tw=79:
