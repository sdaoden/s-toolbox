#!/bin/sh
#@ arena-manager for dummies (should work with sh(1), bash(1), ksh(1) - yeah).
# Top dir where everything happens
#ARENA="$HOME/arena/code.extern"
ARENA="$TMPDIR/x"
#@ Modes:
#@ reduce,expand; update (followed by autogc if indicated); gc|fullgc.
#@ Known tags:
#@ .git, .svn-git, .cvs-git: git(1) (git svn, git cvsimport)
#@ .svn: svn(1)
#@ .cvs: cvs(1)
#@ -no_reduce: skip for "reduce" operation (git(1), hg(1) only)
#@ -no_full_gc: even with "fullgc", never use --aggressive (git(1) only)
#@
#@ I.e.: gnulib.git-no_full_gc, git.git-no_reduce
#@ For "reduce" git(1) repos need a "NULL" branch which contains a single file
#@ "NULL" which contains nothing but a single line stating the branch name of
#@ the "master" branch, i.e. the branch which should be checked out by default.
#@
#@ git(1): this script assumes refs start with 'refs/', followed by 'remotes'
#@ for remotes or 'heads' for locals ('tags' are ignored).  It only compares
#@ against remotes which then are followed by 'origin'.  See below for more.
#
# Copyright (c) 2011 Steffen Daode Nurpmeso <sdaoden@gmail.com>.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
# 3. Neither the name of the author nor the names of its contributors
#    may be used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

GIT=git
HG=hg
SVN=svn
CVS='cvs -fz 9'

##

CVSROOT=/nonexistent
CURR=/nonexistent
# These must be in $ARENA!
LOGFILE=.ARENA-LOG
AUTOGCFILE=.ARENA-AUTOGC
#
ESTAT=0
GITDID=0

log() {
    echo "$*"
    echo "$*" >> $LOGFILE
}
logerr() {
    echo >&2 "ERROR: $*"
    echo "ERROR: $*" >> $LOGFILE
    ESTAT=1
}

SEP='================================================================'
intro() {
    log ''
    log $SEP
    log $1
}
final() {
    if test $1 -eq 0; then
        log "... ok: $2"
    else
        ESTAT=$1
        logerr "$2"
    fi
    log $SEP
}

## git(1) stuff: all called from within subshell with -o pipefail

#git_check_clean() {
#    test 0 != $($GIT clean --dry-run | wc -l | \
#                sed -Ee 's/^[[:space:]]+(.*)$/\1/') && {
#        echo >&2 "Untracked files present, bailing out!" &&
#        exit 10
#    }
#}

git_check_status() {
    test 0 != $($GIT status --short | wc -l | \
                sed -Ee 's/^[[:space:]]+(.*)$/\1/') && {
        echo >&2 "Modified or untracked files present, bailing out!" &&
        exit 10
    }
}

git_checkout() {
    local br="$1"
    $GIT checkout -f $br -- || {
        echo >&2 "Can\'t checkout branch $br, bailing out!" &&
        exit 11
    }
}

_rcguc=0
git_ref_check_gc_update() {
    # Return 41 if no new data, 42 if new data, otherwise error
    test $_rcguc -ne 0 && return $_rcguc

    local branch="$1" autogcfile="$2"
    $GIT show-ref |
    perl -e "\$rd = \"$branch\"; \$agcf = \"$autogcfile\";" -e '
        my (%remotes, %heads);
        while (<STDIN>) {
            chomp;
            my ($sha, $ref) = split;
            #print STDERR "sha<$sha> ref<$ref>\n";
            $ref =~ s/^refs\/(.+)/$1/;
            if ($ref =~ s/^remotes\///) {
                $remotes{$ref} = $sha;
            } elsif ($ref =~ s/^heads\///) {
                $heads{$ref} = $sha;
            } elsif ($ref !~ /^tags/) {
                print STDERR "Skipping unrecognized ref $ref\n";
            }
        }

        my $es = 41;
        open AGCF, ">> $agcf" ||
            die "Cannot open append-write $agcf: $!";
        foreach (keys %remotes) {
            (my $lr = $_) =~ s/^origin\///;
            next unless exists $heads{$lr};
            next if $heads{$lr} eq $remotes{$_};
            $es = 42;
            print "... {at least \"$lr\" and \"$_\" differ, ",
                  "marking for autogc}\n";
            print AGCF $rd, "\n" || die "Cannot write $agcf: $!";
        } 
        close AGCF || die "Cannot close $agcf: $!";
        exit $es;
    '
    _rcguc=$?
    return $_rcguc
}

##

cd $ARENA || {
    echo >&2 "Failed to chdir to $ARENA"
    exit 1
}

if test -e $LOGFILE; then
    mv -f $LOGFILE "${LOGFILE}-LAST" || {
        echo >&2 "Failed to move old $LOGFILE to ${LOGFILE}-LAST"
        exit 1
    }
fi

MODE="$1"
shift
PARAMS="$@"
set -u
test $# -ne 0 || PARAMS=$(echo *.*)
typeset -a params

# Perform basename cleanup and move over to $params[]
# However, autogc mode takes precedence and is mapped to one of fullgc/gc,
# replacing the PARAMS with the content of $AUTOGCFILE
log "$0: script startup, mode $MODE"
if test "$MODE" == autogc; then
    if test ! -s "$AUTOGCFILE"; then
        logerr 'Necessary information for autogc is missing'
        exit 1
    fi
    for r in $(< "$AUTOGCFILE"); do
        params[${#params[*]}]="$r"
    done
    m=$(date +%m)
    if test $(( ${m#0} % 3 )) -eq 0; then
        MODE=fullgc
        log 'Turned over to mode fullgc (not gc since MONTH%3==0)'
    else
        MODE=gc
        log 'Turned over to mode gc'
    fi
else
    for rd in $PARAMS; do
        rd=$(echo "$rd" | sed -Ee 's/(.+)\/+$/\1/' -e 's/.*\/([^/]+)$/\1/')
        params[${#params[*]}]="$rd"
    done
fi

case "$MODE" in
reduce|expand)
    if test "$MODE" == reduce; then
        git_branch='arena-manager-null'
        hg_branch='null'
    else
        git_branch=
        hg_branch=''
    fi

    for rd in ${params[@]}; do
        if [[ "$rd" != ${rd/no_reduce/} || ! ( "$rd" != ${rd/git} ||
              "$rd" != ${rd/hg} ) ]]; then
            log ''
            log "[$rd: $MODE does not apply]"
            continue
        fi

        intro "$rd: performing $MODE"
        set -o pipefail
        (   cd "$rd" || exit 10
            if test "$rd" != ${rd/git}; then
                # File NULL on branch arena-manager-null contains of a single
                # line stating the master branch's name
                if test -z "$git_branch"; then
                    if test -f NULL; then
                        git_branch=$(< NULL)
                    else
                        echo >&2 "No file NULL in $rd"
                        git_branch=master
                    fi
                fi
                $GIT checkout -q $git_branch
            else #elif test "$rd" != ${rd/hg}; then
                $HG up $hg_branch
            fi
            exit $?
        ) 2>&1 | tee -a "$LOGFILE"
        final $? "$rd"
        set +o pipefail
    done
    ;;
update)
    rm -rf $AUTOGCFILE || {
        echo >&2 "Failed to remove stale $AUTOGCFILE"
        exit 1
    }

    for rd in ${params[@]}; do
        if test "$rd" != ${rd/.tar-bomb-git}; then
            log ''
            log "[$rd: (automatic) $MODE does not apply]"
            continue
        fi

        intro "$rd: performing $MODE"
        set -o pipefail
        (   cd "$rd" || exit 9
            if test "$rd" == ${rd/git}; then
                if test "$rd" != ${rd/.hg}; then
                    $HG -v pull #-u
                    es=$?
                elif test "$rd" != ${rd/.svn}; then
                    $SVN update
                    es=$?
                elif test "$rd" != ${rd/.cvs}; then
                    $CVS update -ARPd #C
                    es=$?
                else
                    echo >&2 "Unknown revision-control-system: $rd"
                    es=1
                fi
                exit $es
            fi

            # git(1) and related
            git_check_status

            if test "$rd" != ${rd/.git}; then
                #$GIT pull -v --ff-only --stat --prune
                $GIT fetch --verbose --prune
                es=$?
            elif test "$rd" != ${rd/.svn-git}; then
                $GIT svn rebase
                es=$?
            elif test "$rd" != ${rd/.cvs-bomb-git}; then
                git_checkout arena-manager-download

                $CVS update -ARPd #C
                es=$?
                # Ignore all updates which occur in CVS/ directories, at least
                # for the check if repo content changed
                if test 0 != $($GIT status --porcelain | \
                               sed -Ee '/CVS\/[^\/]+$/d' | wc -l | \
                               sed -Ee 's/^[[:space:]]+(.*)$/\1/'); then
                    echo "... cvs(1) updated some, initiating git(1) commit"
                    $GIT add --all
                    $GIT commit -m 'arena-manager .cvs-bomb-git update'
                    $GIT update-ref refs/remotes/origin/master \
                                    arena-manager-download
                    echo "$rd" >> "$ARENA/$AUTOGCFILE" ||Â exit 20
                else
                    echo "... cvs(1) did not seem to have new data"
                fi

                git_checkout_force master
            elif test "$rd" != ${rd/.cvs-git}; then
                # Go to the branch which stores our configuration stuff
                git_checkout arena-manager-config

                master=$(< git_master)          # The name of the master branch
                cvs_root=$(< cvs_root)          # CVSROOT repo URL (CVS/Root)
                cvs_module=$(< cvs_module)      # CVS module (CVS/Repository)
                cvsps_file=$(< cvsps_file)      # cvsps(1) cache file name
                test -f cvs-revisions && Rflag=-R || Rflag= # git cvsimport dat

                # Prepare cvsps(1) (and git(1) cvsimport) cache
                cvsps_dir="$HOME/.cvsps"
                test -d "$cvsps_dir" || mkdir "$cvsps_dir" || {
                    echo >&2 "$rd: failed to create $cvsps_dir directory"
                    exit 20
                }
                test x"$Rflag" != x && cp -f cvs-revisions .git/
                cp -f cvsps_cache "$cvsps_dir/$cvsps_file"

                # NOTE: we *require* these -r -d etc...
                $GIT cvsimport -ai $Rflag -p '-u,--cvs-direct' \
                     -r origin -d "$cvs_root" "$cvs_module"
                es=$?
                test $es -ne 0 && {
                    echo >&2 "$rd git(1) cvsimport failed, bailing out"
                    git_checkout "$master"
                    exit $es
                }

                git_ref_check_gc_update "$rd" "$ARENA/$AUTOGCFILE"
                if test $? -eq 42; then
                    echo '... committing updated configuration'
                    test x"$Rflag" != x && mv -f .git/cvs-revisions .
                    mv -f "$cvsps_dir/$cvsps_file" cvsps_cache
                    $GIT commit -am 'arena-manager .cvs-git update' || exit 21
                else
                    echo '... cvsimport had nothing, not updating config'
                    test x"$Rflag" != x && rm -f .git/cvs-revisions
                    rm -f "$cvsps_dir/$cvsps_file"
                fi

                git_checkout "$master"
            else
                echo >&2 "Unknown revision-control-system: $rd"
                exit 1
            fi

            git_ref_check_gc_update "$rd" "$ARENA/$AUTOGCFILE"
            exit $es
        ) 2>&1 | tee -a "$LOGFILE"
        es=$?
        set +o pipefail
        final $es "$rd"
    done

    test -s "$AUTOGCFILE" && GITDID=1
    ;;
fullgc|gc)
    GCT=
    test "$MODE" == fullgc && GCT=--aggressive
    for rd in ${params[@]}; do
        if test "$rd" == ${rd/git}; then
            log ''
            log "[$rd: $MODE does not apply]"
            continue
        fi
        m=$MODE
        i=$GCT
        if test "$rd" != ${rd/no_full_gc}; then
            m='gc (fullgc forcefully downgraded)'
            i=
        fi
        intro "$rd: performing $m"
        set -o pipefail
        (   cd "$rd" || exit 1
            time git gc $i
        ) 2>&1 | tee -a "$LOGFILE"
        final $? "$rd"
        set +o pipefail
    done
    ;;
*)
    echo 'USAGE: manager reduce|expand|update|autogc|gc|fullgc LIST-OF-DIRS'
    exit 1
    ;;
esac

log ''
log '++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++'
if test $GITDID -ne 0; then
    log 'Some git(1) repos seem to have new packs, run arena-manager autogc'
fi
if test $ESTAT -ne 0; then
    log 'Errors occurred!  Ooooh, my gooooooood!  :)'
else
    log 'All seems fine around here, ciao'
fi
exit $ESTAT
# vim:set fenc=utf-8 filetype=sh syntax=sh ts=4 sts=4 sw=4 et tw=79:
