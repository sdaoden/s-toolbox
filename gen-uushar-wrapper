#!/bin/sh
#@ gen-uushar-wrapper creates a shar(1)-like shell archive (but with
#@ uuencode(1)d content) of given files (read from STDIN and/or ARGV), that is
#@ itself executable.
#@ Execute it (the generated archive) to invoke any of the programs contained
#@ therein.  On the first run with arguments, the wrapper will create a hidden
#@ directory in your $TMPDIR to unpack the archive therein; without arguments
#@ it'll always print creation time and members shipped.
#@ Web: http://sdaoden.users.sourceforge.net/code.html;
#@      https://sourceforge.net/projects/s-toolbox
#@ Git: git.code.sf.net/p/s-toolbox/code
#
# Copyright (c) 2012, 2013 Steffen "Daode" Nurpmeso <sdaoden@users.sf.net>.
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

##  --  >8  --  8<  --  ##
ARGS=$@

echo 'So let us create an uuencoded shell archive of the given utilities.'
echo 'Please answer the upcoming questions for this to work.'
echo 'You can at any time interrupt with CTRL-C.'

printf '\nWhat should be the name of the wrapper: [] '
read SHAR
[ -f "$SHAR.sh" ] && {
   echo >&2 "$SHAR.sh already exists, bailing out."
   exit 1
}
[ -z "$SHAR.sh" ] && {
   echo >&2 "Cannot use the empty string for that, bailing out."
   exit 1
}
SHAR="$SHAR.sh"

printf "Yay, it'll be $SHAR.\n\n%s\n%s" \
   'Is there any subcommand which should be called for "+"?' \
   "(As in: '\$ $SHAR + -arg1 -arg2' -> '\$ XXX -arg1 -arg2')? [] "
read SHAR_DEFEXEC

printf '\n%s\n%s' \
   'Members can be compressed via compress, gzip, bzip2 and xz.' \
   'Enter desired compressor or the empty string otherwise. [] '
read COMPRESS
[ ! -z "$COMPRESS" ] && {
   x_compress='compress -c -f'
   ux_compress='uncompress -c'
   x_gzip='gzip -c -f'
   ux_gzip='gunzip -c -f'
   x_bzip2='bzip2 --compress --stdout'
   ux_bzip2='bzip2 --decompress --stdout'
   x_xz='xz --compress --stdout'
   ux_xz='xz --decompress --stdout'

   eval cfun='$x_'"$COMPRESS"
   eval xfun='$ux_'"$COMPRESS"
   [ -z "$cfun" ] && {
      echo >&2 "Unsupported compression method: $COMPRESS"
      exit 1
   }
}

echo
echo 'So, we will then enter a loop to read the member programs to include.'
echo 'An empty value will terminate your input.'
MEMBERS= MEMBER_BASENAMES=
[ -n "$ARGS" ] && set -- $ARGS
while :; do
   [ -n "$ARGS" ] &&
      { [ $# -eq 0 ] && break; i=$1; shift; printf '\t- '; :; } ||
      { printf '\t - [] '; read i; [ -z "$i" ] && break; }
   [ -x "$i" ] || {
      echo >&2 "$i does not exist or is not executable, bailing out."
      exit 1
   }
   j=`basename "$i"`
   [ -z "$MEMBERS" ] &&
      { MEMBERS="$i" MEMBER_BASENAMES="$j"; } ||
      { MEMBERS="$MEMBERS, $i" MEMBER_BASENAMES="$MEMBER_BASENAMES, $j"; }
   echo "$i: ok"
done

# Everything get.set.go, so write the actual shell archive
# (Not backward compatible with Bourne [-C], atomicity problem: set -C)
echo '.. end of list'
echo 'Fine, so i am doing my work now ...'
CREATION_DATE=`date -u`

# Header
cat <<\! > "$SHAR"
#!/bin/sh -
#@ This file has been created by gen-uushar-wrapper, which is
# Copyright (c) 2012 Steffen "Daode" Nurpmeso <sdaoden@users.sf.net>.
#@ by means of the ISC license.
#@ It contains a shell-archive-execution-environment. ;}
#@ Run it, and it will tell you which executable files it contains.
#@ Run it with the name of such an executable, and it'll create a hidden
#@ directory in your $TMPDIR to expand the shipped executables.
#@ From then on, it'll redirect it's invocations to those programs.
#
#@ Archives produced using this implementation of gen-uushar-wrapper
#@ may be easily examined with the command:
#@    $ grep '^[^X#]' shell-archive

!

# It's indeed our $SHAR
trap "rm -rf '$SHAR'" 0

# A shell archive is not a transparent thing either!
echo >> "$SHAR" "SHAR='$SHAR'"
echo >> "$SHAR" "CREATION_DATE='$CREATION_DATE'"
echo >> "$SHAR" "MEMBERS='$MEMBER_BASENAMES'"
echo >> "$SHAR" '# Default expansion (if argument $1 equals +):'
echo >> "$SHAR" "DEFEXEC='$SHAR_DEFEXEC'"
cat <<\! >> "$SHAR"
#
[ $# -eq 0 ] && {
   echo "Archive creation: $CREATION_DATE"
   echo "Members: $MEMBERS"
   exit 0
}
#
i="$TMPDIR/.$SHAR"
[ -d "$i" ] && {
   PATH="$i:$PATH"
   export PATH
   [ x"$1" = 'x+' ] && { shift; :; } || { DEFEXEC=$1; shift; }
   i="$i/$DEFEXEC"
   if [ ! -f "$i" ] || [ ! -x "$i" ]; then
      echo >&2 "Sorry, this archive no program '$DEFEXEC', bailing out"
      exit 54
   fi
   exec "$i" ${@+"$@"}
   echo >&2 "Failed to execute <$DEFEXEC ${@+\"${@}\">"
   exit 71 # 71=EX_OSERR
}
#
echo 'The directory'
echo "	$i"
echo 'does not exist, creating it first, and expanding this shell archive..'
mkdir -p "$i" || {
   echo >&2 "Cannot create directory '$i'"
   exit 1
}
cd "$i" || {
   echo >&2 "Cannot chdir '$i' to expand shell archive"
   exit 1
}
#
!

# uuencode(1)d and optionally compress the members to embed
oifs=$IFS
IFS=', '
set -- $MEMBERS
IFS=$oifs
for i
do
   bi=`basename "$i"`
   echo >> "$SHAR" "echo 'X - $bi'"
   if [ -z "$cfun" ]; then
      echo >> "$SHAR" \
         "sed 's/^X//' << \! | uudecode > \"$bi\"; chmod 0755 \"$bi\""
      < "$i" uuencode -m /dev/stdout | sed 's/^/X/' >> "$SHAR"
   else
      echo >> "$SHAR" \
         "sed 's/^X//' << \!| uudecode | $xfun > \"$bi\"; chmod 0755 \"$bi\""
      < "$i" $cfun | uuencode -m /dev/stdout | sed 's/^/X/' >> "$SHAR"
   fi
   echo >> "$SHAR" '!'
   echo >> "$SHAR" "# END of $bi"
done

echo >> "$SHAR" "echo 'SHAR is now expanded, please rerun your command'"
echo >> "$SHAR" 'exit 0'

# The end
chmod 0755 "$SHAR"
trap : 0
exit 0
# vim:set fenc=utf-8 syntax=sh ts=8 sts=3 sw=3 et tw=79:
