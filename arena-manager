#!/bin/sh
#@ arena-manager for dummies (should work with sh(1), bash(1), ksh(1) - yeah).
#@ Modes:
#@ reduce,expand; update (followed by autogc if indicated); gc|fullgc.
#@ Known tags:
#@ .git, .svn-git, .cvs-git: git(1) (git svn, git cvsimport)
#@ .svn: svn(1)
#@ .cvs: cvs(1)
#@ -no_reduce: skip for "reduce" operation (git(1), hg(1) only)
#@ -no_full_gc: even with "fullgc", never use --aggressive (git(1) only)
#@
#@ I.e.: gnulib.git-no_full_gc, git.git-no_reduce
#@ For "reduce" git(1) repos need a "NULL" branch which contains a single file
#@ "NULL" which contains nothing but a single line stating the branch name of
#@ the "master" branch, i.e. the branch which should be checked out by default.
#@
#@ git(1): this script assumes refs start with 'refs/', followed by 'remotes'
#@ for remotes or 'heads' for locals ('tags' are ignored).  It only compares
#@ against remotes which then are followed by 'origin'.  See below for more.
#
# Copyright (c) 2011 Steffen Daode Nurpmeso <sdaoden@gmail.com>.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
# 3. Neither the name of the author nor the names of its contributors
#    may be used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# Top dir where everything happens
ARENA="$HOME/arena/code.extern.repos"

GIT=git
HG=hg
SVN=svn
CVS='cvs -fz 9'

##

CVSROOT=/nonexistent
CURR=/nonexistent
# These must be in $ARENA!
LOGFILE=.ARENA-LOG
AUTOGCFILE=.ARENA-AUTOGC
#
ESTAT=0
GITDID=0

log() {
    echo "$*"
    echo "$*" >> $LOGFILE
}
logerr() {
    echo >&2 "ERROR: $*"
    echo "ERROR: $*" >> $LOGFILE
    ESTAT=1
}

SEP='================================================================'
intro() {
    log ''
    log $SEP
    log $1
}
final() {
    if test $1 -eq 0; then
        log "... ok: $2"
    else
        ESTAT=$1
        logerr "$2"
    fi
    log $SEP
}

##

cd $ARENA || {
    echo >&2 "Failed to chdir to $ARENA"
    exit 1
}

if test -e $LOGFILE; then
    mv -f $LOGFILE "${LOGFILE}-LAST" || {
        echo >&2 "Failed to move old $LOGFILE to ${LOGFILE}-LAST"
        exit 1
    }
fi

MODE="$1"
shift
PARAMS="$@"
set -u
test $# -ne 0 || PARAMS=$(echo *.*)
typeset -a params

# Perform basename cleanup and move over to $params[]
# However, autogc mode takes precedence and is mapped to one of fullgc/gc,
# replacing the PARAMS with the content of $AUTOGCFILE
log "$0: script startup, mode $MODE"
if test "$MODE" == autogc; then
    if test ! -s "$AUTOGCFILE"; then
        logerr 'Necessary information for autogc is missing'
        exit 1
    fi
    for r in $(< "$AUTOGCFILE"); do
        params[${#params[*]}]="$r"
    done
    m=$(date +%m)
    if test $(( ${m#0} % 3 )) -eq 0; then
        MODE=fullgc
        log 'Turned over to mode fullgc (not gc since MONTH%3==0)'
    else
        MODE=gc
        log 'Turned over to mode gc'
    fi
else
    for rd in $PARAMS; do
        rd=$(echo "$rd" | sed -Ee 's/(.+)\/+$/\1/' -e 's/.*\/([^/]+)$/\1/')
        params[${#params[*]}]="$rd"
    done
fi

case "$MODE" in
reduce|expand)
    if test "$MODE" == reduce; then
        git_branch='NULL'
        hg_branch='null'
    else
        git_branch=
        hg_branch=''
    fi

    for rd in ${params[@]}; do
        if [[ "$rd" != ${rd/no_reduce/} || ! ( "$rd" != ${rd/git} ||
              "$rd" != ${rd/hg} ) ]]; then
            log ''
            log "[$rd: $MODE does not apply]"
            continue
        fi

        intro "$rd: performing $MODE"
        set -o pipefail
        (   cd "$rd" || exit 10
            if test "$rd" != ${rd/git}; then
                # On branch NULL file NULL contains master branch's name
                if test -z "$git_branch"; then
                    if test -f NULL; then
                        git_branch=$(<NULL)
                    else
                        echo >&2 "No file NULL in $rd"
                        git_branch=master
                    fi
                fi
                $GIT checkout -q $git_branch
            else #elif test "$rd" != ${rd/hg}; then
                $HG up $hg_branch
            fi
            exit $?
        ) 2>&1 | tee -a "$LOGFILE"
        final $? "$rd"
        set +o pipefail
    done
    ;;
update)
    rm -rf $AUTOGCFILE || {
        echo >&2 "Failed to remove stale $AUTOGCFILE"
        exit 1
    }

    for rd in ${params[@]}; do
        intro "$rd: performing $MODE"
        set -o pipefail
        (   cd "$rd" || exit 10
            if test "$rd" != ${rd/.git}; then
                #$GIT pull -v --ff-only --stat --prune
                $GIT fetch --verbose --prune
                es=$?
            elif test "$rd" != ${rd/.svn-git}; then
                $GIT svn rebase
                es=$?
            elif test "$rd" != ${rd/.cvs-bombgit}; then
                $GIT co remotes/origin/master
                $CVS update -ARPd #C
                es=$?
                $GIT add --all && $GIT ci -m 'arena-manager .cvs-bombgit update'
                $GIT co master
            elif test "$rd" != ${rd/.cvs-git}; then
                ldir='.git/.cvsps'
                tar xjf "$ldir.tbz" || {
                    echo >&2 "$rd: bail: tar xjf $ldir.tbz"
                    exit 11
                }
                cp -f "$ldir.tbz" "$ldir.tbz.last"
                hdir="$HOME/.cvsps"
                test -d "$hdir" || mkdir "$hdir" || {
                    echo >&2 "$rd: failed to create $hdir directory"
                    exit 12
                }
                root="$ldir/CVSROOT"
                repo="$ldir/MODULE"
                cache=$(<$ldir/CVSPS_FILE)
                mv -f "$ldir/cvs-revisions" .git/
                mv -f "$ldir/$cache" "$hdir/$cache"
                $GIT cvsimport -aR -r origin -p '-u,--cvs-direct' \
                     -d $(<$root) $(<$repo)
                es=$?
                mv -f .git/cvs-revisions "$ldir/"
                mv -f "$hdir/$cache" "$ldir/$cache"
                tar cjf "$ldir.tbz" "$ldir" || {
                    echo >&2 "$rd: bail: tar cjf $ldir.tbz $ldir"
                    exit 13
                }
                rm -rf $ldir
            elif test "$rd" != ${rd/.hg}; then
                $HG -v pull #-u
                es=$?
            elif test "$rd" != ${rd/.svn}; then
                $SVN update
                es=$?
            elif test "$rd" != ${rd/.cvs}; then
                $CVS update -ARPd #C
                es=$?
            else
                echo "Unknown revision-control-system: $rd"
                es=1
            fi

            if test "$rd" != ${rd/git}; then
                git show-ref |
                perl -e "\$rd = \"$rd\"; \$agcf = \"$ARENA/$AUTOGCFILE\";" -e '
                    my (%remotes, %heads);
                    while (<STDIN>) {
                        chomp;
                        my ($sha, $ref) = split;
                        #print STDERR "sha<$sha> ref<$ref>\n";
                        $ref =~ s/^refs\///;
                        if ($ref =~ s/^remotes\///) {
                            $remotes{$ref} = $sha;
                        } elsif ($ref =~ s/^heads\///) {
                            $heads{$ref} = $sha;
                        } elsif ($ref !~ /^tags/) {
                            print STDERR "Skipping unrecognized ref $ref\n";
                        }
                    }

                    open AGCF, ">> $agcf" ||
                        die "Cannot open append-write $autogcfile: $!";
                    foreach (keys %remotes) {
                        (my $lr = $_) =~ s/^origin\///;
                        next unless exists $heads{$lr};
                        next if $heads{$lr} eq $remotes{$_};
                        print "... {at least \"$lr\" and \"$_\" differ, ",
                              "marking for autogc}\n";
                        print AGCF $rd, "\n";
                    }
                '
            fi
            exit $es
        ) 2>&1 | tee -a "$LOGFILE"
        es=$?
        set +o pipefail
        final $es "$rd"
    done

    test -s "$AUTOGCFILE" && GITDID=1
    ;;
fullgc|gc)
    GCT=
    test "$MODE" == fullgc && GCT=--aggressive
    for rd in ${params[@]}; do
        if test "$rd" == ${rd/git}; then
            log ''
            log "[$rd: $MODE does not apply]"
            continue
        fi
        m=$MODE
        i=$GCT
        if test "$rd" != ${rd/no_full_gc}; then
            m='gc (fullgc forcefully downgraded)'
            i=
        fi
        intro "$rd: performing $m"
        set -o pipefail
        (   cd "$rd" || exit 1
            time git gc $i
        ) 2>&1 | tee -a "$LOGFILE"
        final $? "$rd"
        set +o pipefail
    done
    ;;
*)
    echo 'USAGE: manager reduce|expand|update|autogc|gc|fullgc LIST-OF-DIRS'
    exit 1
    ;;
esac

log ''
log '++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++'
if test $GITDID -ne 0; then
    log 'Some git(1) repos seem to have new packs, run arena-manager autogc'
fi
if test $ESTAT -ne 0; then
    log 'Errors occurred!  Ooooh, my gooooooood!  :)'
else
    log 'All seems fine around here, ciao'
fi
exit $ESTAT
# vim:set fenc=utf-8 filetype=sh syntax=sh ts=4 sts=4 sw=4 et tw=79:
